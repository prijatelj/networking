\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[autostyle, english = american]{csquotes}
\MakeOuterQuote{"}
\usepackage[backend=biber,style=numeric,sorting=ynt]{biblatex}
\addbibresource{res.bib}
\DeclareNameAlias{default}{last-first}
\usepackage{fancyhdr}
%\usepackage{graphicx}
\usepackage[a4paper, margin = 1in]{geometry}
\usepackage{titlesec}
    \titleformat*{\section}{\normalfont\bfseries}
    \titleformat*{\subsection}{\normalfont\itshape}
\linespread{1.3}
\begin{document}
\begin{titlepage}
\begin{center}
        \large
        \textbf{Terminus: A Simple Text-based, Real-time, Two Player Versus, Top-Down Shooter Game}\\
        \normalsize
        \vspace{0.5cm}
        Derek S. Prijatelj\\
        COSC 450: Computer Networks\\
        Department of Mathematics and Computer Science\\
        Duquesne University\\
        \today\\
        https://github.com/prijatelj/networking/tree/master/Terminus
    \end{center}
\section*{Abstract}
    To better understand both real-time networking implementations and text-based games, I created the game "Terminus". Terminus is a simple text-based game based on the client-server architecture with real-time networking requirements for a competitive two player standoff in a top-down shooter. A dedicated server initiates the queuing process for the game, waits for two players to connect, and then manages their gameplay over a transmission control protocol (TCP) connection using lightweight data transfer. My experience with this simple game enlightened me on the complexities of real-time synchronous gaming with only TCP as the means of communication, as well as provided me with adequate beginning experience in networking with the Java NIO API. This report details the project and involved networking techniques.

\end{titlepage}
\pagestyle{fancy}
\lhead{COSC 450: Computer Networks}
\chead{Terminus}
\rhead{Derek S. Prijatelj}

\section{Introduction}
    Modern games emphasize the state-of-the-art graphics, game-based artificial intelligence, databases, and networking techniques. While these factors of modern games are impressive, it sometimes can be beneficial to recollect where these techniques all started either for learning to improve the modern systems based on past knowledge, or to appreciate how far the art of game development has progressed over the years. In order to better understand the development of the beginnings of video games, I decided to make a simple text-based game that represents a game that would potentially be played on a system similar to that which would play the original game "Pong", but has a modern underlying structure. To accomplish this I chose to create my game, called "Terminus" in Java for the modern underlying structure, heavily using the Java New Input Output (NIO) API for a contemporary network architecture and JavaFX for a current graphical user interface API. For retro text-based gameplay, I built the game from scratch using a two-dimensional array of characters as the game board. The following goes into depth on the game design itself, the materials used in development, and the networking method implemented in Terminus, respectively.
    
\section{The Game Defined}
    Terminus is a text-based, real-time, two player versus, top-down shooter game. It is meant to have the look and feel of a retro text-based game, but have a modern infrastructure. The game involves two players connected together via a dedicated server. There are limited user inputs including move left (`a' key), move right (`d' key), shoot missile (`s' key), and self-destruct or forfeit (`x' or `esc' keys). The objective of the game is to destroy the enemy ship by tactically launching missiles at the opponent before they are capable of destroying your own vessel. In this version of Terminus, all players have 3 hit-points and 5 total timer-based reloadable missiles. Each hit-point equates to how many times a player may be hit by a missile before they lose. Missiles will implode upon contact with either another missile or a player ship. This means that missiles can be used both offensively and defensively. This also introduces some level of skill required from the player because they cannot simply spray all their missiles in one moment, because if their own missiles occupy the same tile on the board then they will be destroyed. The timer-based reloading of missiles also introduces the necessity of tactics in using one's missiles. Whenever a player either loses all of their hit-points or self-destructs, they lose and the opponent wins that game. The connection to the dedicated server is then severed, the sever program shuts down and the client programs stall on the last animation frame of the game until closed by the user.
    
    Terminus is displayed in a simple black background, white foreground window, where the text creates the board. The in-game board is a simple rectangle with a character `A' at the bottom and a character `V' at the top. The `A' always represents the user of the client program, and the `V' represents the opponent. Missiles for the user appear as the character `\verb|^|' and the opponent's missiles appear as the character `v'. Below the board is the stats of both players, appropriately labeled "Your Stats" and "Opponent" to indicate whose stats are whose. In this stats box, the hit-points and currently available ammo of the players are visible. This is the simple graphical user interface of Terminus. 
    
    Real-time in games has the same definition as that of other real-time computing systems. Real-time computing systems control their environment by receiving and processing given data, and affecting their environment based on that processed data in a sufficiently short amount of time \cite{martin}. Real-time networking is a necessity in non-turn-based multiplayer games, such as Massive Multiplayer Online Role-Playing Games (MMORPG), or First Person Shooters (FPS). The difficulty in real-time networking games lies in the need for synchronized gaming, where the game state is as similar as possible between players across the network, and the required low latency in the transfer of packets. Packets are segmented chunks of data from a larger entity that are used as more manageable parts of the whole for transfer across networks\cite{kurose}. Terminus implements real-time networking by relying on all clients and servers simulating the game and using a small data-foot print for its transfered data to maintain the game state across clients and the server. A game state refers to the active state of the game, which for Terminus includes the players' and missile's status and location. The synchronization of game states across all clients is ensured by using a reliable,  ordered, and error-checked transport layer protocol. Terminus uses the Transmission Control Protocol (TCP). The details for Terminus' use of this transport layer protocol and how it maintains the requirements for a real-time system are detailed in the later Method section.

\section{Materials}
    The materials in this project are software only, due to Terminus being written in the Java programming language for maximum portability. Java also provides two APIs that are relied upon in the creation of Terminus. These API's are JavaFX for implementing an up-to-date graphical user interface backend, and Java New Input Ouput (NIO) for handling the network requirements of Terminus. These two APIs are briefly detailed before discussing the main network method utilized for Terminus.

\subsection{JavaFX}
    JavaFX is the graphics and media Java API offered by Oracle. As of Java 8, it is an official part of the standard Java library. JavaFX was meant as a replacement to the older java graphics API Swing \cite{oracle}. The main purpose of JavaFX is to provide an easy to use API for creating customizable desktop graphical user interfaces (GUI). Although it is a standard for GUI development, it is not intended nor optimized for game development, but given the light weight of Terminus, it serves as a useful API to allow basic keyboard input and animation that the standard virtual terminal is not capable of providing standard Java. JavaFX is applies CSS for styling of the GUI and is capable of animation at the rate of 60 frames per second by default. This is a useful feature for Terminus' networking needs where the animation frame rate will be manipulated in order to control the speed of TCP packet transmission rate from the client to the server. For every animation frame, a write and read cycle from client to server is completed. The frame-rate then offers an inherent timer for querying the server, which proves useful for this specific project. This will be further detailed in the Method section.

\subsection{Java NIO}
    Java NIO is an alternative to the existing Java IO APIs. Java NIO is a collection of Java APIs that offer features for intensive input/output operations to facilitate the use of the most efficient operations of the underlying platform \cite{nio}. Java NIO is comprised of its own defined APIs for new buffers, character set encoders and decoders, channels, file interface, pattern-matching, and a multiplexed, non-blocking I/O facility for writing scalable servers. Scalability has heavy emphasis in Java NIO and is the main reason Terminus utilizes it over the standard Java IO APIs. Although I admit that the current implementation of Java NIO in Terminus is not the most scalable structure, the Terminus project has allowed me to experiment with something new and useful. If there is future work on Terminus, then I intend to make it have a fully flexible and scalable client-server architecture with the use of Java NIO. Currently, Terminus utilizes the Server Socket Channel and Server Socket features for TCP connections, both blocking and non-blocking depending on where the client and server are in their application layer protocol. Java NIO provides Terminus with future scalability and provided me with experience with the standard for input/output facilitation in Java.

\section{Method}
    The method detailed here explains the how and why certain networking techniques were implemented in Terminus. Terminus focuses on real-time networking with a client-server architecture.

\subsection{Protocol}
    First I will define how the client and server communicate with one another through their innate protocol. A protocol is "the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event" \cite{kurose}. The communicating entities in Terminus' case with the client-server architecture is the client and the server. The client and sever communicate from their application specified protocol, through their transport layer protocol, TCP, and then through the data and link layers, through the actual physical medium, and then back up to the opposite application layer protocol. Terminus' Application layer protocol is detailed in section \ref{appLayer} and the transport layer protocol that Terminus uses in section \ref{tcp}.
    
    The application layer protocol in Terminus is inherent in both the server and client java applications. This is due to the protocol being dependent on user input on the client side and the fact that JavaFX's animation frame rate timer was used to control the timing of reading and writing data from the client to the server. This probably would not be a good implementation in larger projects, but, as stated before, JavaFX was used due to its convenience, not due to it being optimal for game development.
    
\subsection{Transport Layer: Transmission Control Protocol (TCP)}\label{tcp}
    Transmission Control Protocol (TCP) is a transport layer protocol known for its reliability, order, and error-checking. TCP is often used for the displaying of web pages and delivery of emails. Due to TCP's reliability, it is useful whenever it is important that the content gets to its destination without data loss. TCP's order property means that the order the packets are sent are the order the packets are received and so the data will not be intermixed and will not require reordering back together before they can remake the original entity the packets were derived from \cite{kurose}. The error-checking in TCP helps ensure that the data in the packet is as it was when sent from its source.

    Although TCP is reliable, ordered, and has error-checking, these benefits can also serve to be its downfall in certain scenarios. TCP has it built into the protocol that it will slow down the rate of transfer if it does not receive acknowledgements for the packets its sends, because it is attempting to counteract congestion \cite{kurose}. This causes a problem for time sensitive systems, such as real-time systems. TCP also has a heavier data foot print than that of some alternative transport protocols, such as User Datagram Protocol (UDP). This larger foot print means that when large data needs segmented and encapsulated more than moderate size data, TCP's large wrapper will not allow as much data to be transfered and can cause some delays. Despite error-checking being a nice feature, it takes time to do the computation, and when there are many packets, this can contribute to the slowing down of packet delivery. All three of these features can increase the likelihood of slowing down the transmission of data, which is a problem for real-time systems. UDP does not have these three features and UDP tends to be better fit for tasks that prioritize speed over reliability, order, and error-checking. This makes UDP a better fit for streaming content such as audio and video. With these two protocols excelling at two different tasks very well, the combination of the two is inevitable for systems that want an in between. Some systems use both or combine the two's features by applying the function of one on top of the other in the application layer. The best choice of action in practice is to use the right protocol for the right job and apply features of the protocols at different layers if necessary.
    
    While UDP may be better fit for streaming and for some cases in online gaming, Terminus does not require the use of UDP. Terminus uses TCP rather than UDP because of Terminus' minimal data footprint for data transfer and necessity for reliability. The small data size being transfered in Terminus during the game allows Terminus to counteract the larger TCP packet wrapper and avoid being split up into smaller parts in the first place. Because every packet has the necessary information required for both client and sever, there is no need to wait for more packet transmission and thus overcoming the drawback of the larger packet size slowing down transmissions. Fortunately, this also counteracts the time required to do error-checking. Due to TCP ensuring reliability and its drawback of larger packet encapsulation and time taken for error-checking being overcome, Terminus is capable of using TCP alone and still meeting its real-time requirements.
    
\subsection{Terminus Application Layer Protocol}\label{appLayer}
    A dedicated server initiates the server program with a specified port number and after establishing its internal settings, such as the game settings, the server awaits a client to query it for a connection via its Java NIO Server Socket Channel. Let there be a person somewhere who decides they would like to play a game of Terminus and they know the dedicated server's host name and open port, so they run the client program on their system with the appropriate host name and port number. The client program will then use a Server Socket to open a connection between themself and the dedicated server. Given that the server was awaiting a connection and all is well with the TCP protocol, they establish a connection. The server send the client 16 bytes of information for creating the client-side game. This information is four integer values consisting of the game board's height, width, player hit-points, and a player id of either '1' or '2'. In this case the server sends a 1 as the player id because this client is the first to connect to the server. The first client creates their game with the server's specified values and sits in standby waiting for another player to join the server.
    
    After the first player has successfully connected, the dedicated server then begins to listen for a second player. Once another person runs the client program and connects to the server's hostname and port, they repeat the same exchange as above, except the second client is given a player id of 2, which informs this client that there is already another player ready to play. The second client then creates a game with two players. The server informs the first player that there is another player by sending two characters 'p' and '2' to the client and then waits one second for the two clients to finish initializing their games. The first player then adds a second player to their client-side game. When there are two players in the client-side game, the client then continuously reads and writes to the server at a rate of approximately 60 packets per second, to match that of the animation frame rate. At this point the clients only send one character to the server and receive 2 characters. These two characters correspond to the server's most recent registered input from both players in the current server frame of the game. The server waits for a brief period referred to as a server frame and in this time period collects the most recent input from the two players. The server then updates its own simulated game with their inputs and sends the pair of inputs properly to each player. The players then update their game to match that of the server. The game continues with this exchange until either a player dies or forfeits.
    
    The simple exchange of at most 4 bytes per TCP packet allows Terminus to meet the real-time requirements and create apparently seamless gameplay for the two players. With the TCP underlying transport protocol, the states of the games are ensured to match the server's game state, which ensures the the game's synchronization across the clients' simulated games. Whenever a player loses all of their hit-points or forfeits, their ship is replaced with an 'X' character and their input then turns into a simple 'x'. The server receives this, acknowledges the defeat of the player and then sends the input to both clients. After the final input has been sent, the server severs its connections to the players and terminates. The defeated now has the updated text on their screen stating their opponent has won and they close their Socket Channel to the server, or if they forfeited using the escape key, their application quits and severs their connection to the server automatically after receiving the final input. The victorious client is informed of their victory and they then cut their connection to the server. The user then terminates the client application as they desire after enjoying the snapshot of the final moment of their victory.

\section{Conclusion}
    Terminus is a simple text-based, real-time, two player versus, top-down shooter game. In its creation I applied my previous knowledge of computer networks from my computer networking class, but I also learned new things from working on Terminus. I earned some experience in working with Java NIO for input and output facilities. I also learned more about synchronous and asynchronous systems and how they apply to networking. Java NIO is structured to create scalable servers that make optimal use of the underlying platform of the application. A part of what makes a server scalable is the multiplexing, non-blocking, and asynchronous features of the server, allowing for more dynamic control of the contents in that server. Terminus depicts my knowledge and experience gained from the computer networking class at Duquesne University and serves as a fun simple game to share with others.
    
    For future work on Terminus, there is the chance to optimize the client-server architecture, as well as make it more scalable by taking advantage of Java NIO's benefits. The server code could be improved to allow multi-threading, and thus allow more games to occur on one sever. On a game design stand point alone, Terminus could be improved by polishing the controls and allowing for some more features to expand the game's interest and skill level. Some such features include allowing the player to hold down the shoot key and charge the missiles, consuming more ammo for an increase in speed and damage. This alone could increase the skill by adding a risk and reward factor to the game. Another feature that could be added is to allow the users to move vertically, at least to the half way point of the board. Terminus also could benefit from balancing from gameplay tests to decide what speeds, total hit-points, and board size combinations are the best for quality gameplay. Fortunately, there are multiple direction to go for further development of Terminus, if so desired.

    \pagebreak
    \printbibliography
\end{document}

